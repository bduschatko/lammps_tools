from datetime import datetime
from os import environ, mkdir, getcwd
from os.path import join, exists
from shutil import rmtree, copy
from glob import glob
from typing import List
import subprocess

class Sampler():
    """
    This class creates an interface between a custom ASE calculator and an 
    external code or method used to compute constrained dynamics / 
    sampling data. 

    Args:

        save_files (List): an optional list of files generated by the sampler 
                            that should be saved after a run. Files can be
                            listed using file extensions or explicit names
        save_path (str): an optional path indicating where to save generated 
                            files
        run_environment (dict): environment variables that should be set before
                                running some code. Examples might include the
                                number of OMP threads, or other custom variables
        work_path (str): the working directory to run sampling within 
    
    """

    def __init__(self,
                save_files: List=None, # list of files to save after runs 
                save_path: str=None, # where to store saved files
                run_environment: dict={}, # environment variables for the run
                work_path: str=None,
                **kwargs
                ) -> None:

        # set default property values
        self._init_properties()

        self.run_environment = run_environment
        self._create_pre_run_environment() # get initial environment variables

        # create sampler working directory
        if work_path is None:
            time_string = datetime.now().strftime("%Y.%m.%d:%H:%M:%S:")
            self.work_path = join(getcwd(), "{}SAMPLER_WORK_DIR".format(time_string))
            # do not overwrite directory unless one is given
            if exists(self.work_path): 
                raise OSError(
                    "The working directory {} already exists".format(
                                                                self.work_path))
            else: mkdir(self.work_path)

        else:
            self.work_path = work_path
            if not exists(self.work_path): mkdir(self.work_path)
        
        self.save_path = save_path
        self.save_files = save_files


    # Public functions ---------------------------------------------------------


    def run(self, system_list: List) -> None:
        """
        Run the sampling module 

        : system_list : a list of arbitrary system objects used to create 
                        parallel running processes. Each element is an object
                        containing information relevant to generating inputs
        """

        self.call_counter += 1
 
        # reset process path list 
        self.process_path_list = []
        self.process_save_path_list = []

        # reset command string
        command_string = ""

        self._set_environment_variables()

        for pid, system in enumerate(system_list):

            self._create_run_path(pid)
            self._generate_inputs(system, pid)
            command_string = self._update_command_string(command_string, pid)

        # call command string
        command_string += " wait"

        subprocess.run(command_string, shell=True)

        self._conclude_run()

        return None


    # Private functions --------------------------------------------------------


    def _init_properties(self) -> None:
        """
        Set default sampler properties
        """

        self.run_environment = {}
        self.pre_run_environment = {}
        self.work_path = None 
        self.save_path = None
        self.save_files = None
        self.call_counter = 0 # the number of times the sampler has been called
        self.process_path_list = None
        self.process_save_path_list = None

        return None


    def _create_pre_run_environment(self) -> None:
        """
        Get current system values of any environment variables that will be 
        overwriten by the run environment settings
        """

        for var in self.run_environment.keys():
            current_value = environ.get(var)
            self.pre_run_environment[var] = current_value

        return None


    def _set_environment_variables(self) -> None:
        """
        Set environment variables, such as OMP_NUM_THREADS. Variables pertaining
        to schedulers, such as the SLURM manager, should be specified elsewhere
        """

        # save current environment variables
        for var in self.run_environment.keys():
            
            value = self.run_environment[var]
            if isinstance(value, int) or isinstance(value,float):
                value = str(value)
            environ[var] = value

        return None


    def _revert_environment_variables(self) -> None:
        """
        Reset environment variables to what they were prior to the run
        """

        for var in self.pre_run_environment.keys():
            if self.pre_run_environment[var] is not None:
                environ[var] = self.pre_run_environment[var]

        return None 


    def _generate_inputs(self, id: int):
        """
        Create input files necessary to run code for a process 
        """
        pass


    # create working directory for process id within sampler work space
    def _create_run_path(self, id: int) -> None:
        """
        Create the working directory for a sampling process, and add the path
        to a list of process directories
        """

        process_name = "process_{}".format(id)
        process_path = join(self.work_path, process_name)
        self.process_path_list.append(process_path)
        mkdir(process_path)

        return None


    def _update_command_string(self, command_string: str, id: int) -> str:
        """
        Make changes to the string used to run code from the shell
        """
        return command_string


    def _save_outputs(self) -> None:
        """
        Save the requested outputs following a run. This is done by looping 
        through each process directory and saving the respective files
        """

        # create save directory for this call counter 
        save_path = join(self.save_path, "call-{}".format(self.call_counter))
        mkdir(save_path)

        for pid, path in enumerate(self.process_path_list):

            # create save subdirectory for this process
            process_save_path = join(save_path, "process-{}".format(pid))
            mkdir(process_save_path)
            self.process_save_path_list.append(process_save_path)

            # for this process loop through files to save
            for item in self.save_files:

                # get possible multi-match file paths
                save_files = glob(join(path, item))

                # TODO warning if no files match

                for f in save_files:
                    copy(f, process_save_path)

        return None


    def _clean_work_space(self) -> None:
        """
        Delete the workspace used for the run and associated files
        """

        # remove all files contained within SAMPLER_WORK_DIR
        for path in self.process_path_list:
            rmtree(path)

        return None


    def _conclude_run(self) -> None:
        """
        Reset environment variables, save the outputs, and clean the working 
        directory
        """

        self._revert_environment_variables()
        self._save_outputs()
        self._clean_work_space()

        return None


    # Properties ---------------------------------------------------------------


    @property
    def save_files(self):
        return self._save_files

    @save_files.setter
    def save_files(self, value):
        if value is None or isinstance(value, List):
            self._save_files = value
        else:
            raise TypeError("Files attribute must be None or a list")

    @property
    def pre_run_environment(self):
        return self._pre_run_environment

    @pre_run_environment.setter
    def pre_run_environment(self, value):
        self._pre_run_environment = value 

    @property
    def run_environment(self):
        return self._run_environment 

    @run_environment.setter
    def run_environment(self, value):
        self._run_environment = value

    @property
    def work_path(self):
        return self._work_path

    @work_path.setter
    def work_path(self, value):
        self._work_path = value

    @property
    def save_path(self):
        return self._save_path

    @save_path.setter
    def save_path(self, value):
        self._save_path = value

    @property
    def process_path_list(self):
        return self._process_path_list

    @process_path_list.setter
    def process_path_list(self, value):
        if value is None:
            self._process_path_list = []
        else:
            self._process_path_list = value
    
    @property
    def process_save_path_list(self):
        return self._process_save_path_list

    @process_save_path_list.setter
    def process_save_path_list(self, value):
        if value is None:
            self._process_save_path_list = []
        else:
            self._process_save_path_list = value

    @property
    def call_counter(self):
        return self._call_counter 

    @call_counter.setter
    def call_counter(self, value):
        self._call_counter = value
